<!DOCTYPE html>
<html lang="en" dir="ltr" prefix="og: https://ogp.me/ns#">
  <head>
    <meta charset="utf-8" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CW0S29TLQS"></script>
<script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments)};gtag("js", new Date());gtag("set", "developer_id.dMDhkMT", true);gtag("config", "G-CW0S29TLQS", {"groups":"default","page_placeholder":"PLACEHOLDER_page_location"});</script>
<meta name="description" content="9/2/21 Let polymorphism We would like to have polymorphism in certain circumstances. For example, we would like to have the same identity function λx:x that could be used on Booleans and Integers, without having to have two separate identity functions, one of type B-&gt;B and the other of type I-&gt;I . The usual way to do this, in this setting, is via a &#039;let&#039; construction. Most functional programming languages have an expression form similar to" />
<meta name="author" content="Frické, Martin" />
<meta name="dcterms.creator" content="Frické, Martin" />
<meta name="Generator" content="Drupal 10 (https://www.drupal.org)" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="alternate" hreflang="en" href="https://softoption.us:8888/node/714" />
<link rel="icon" href="/files/softOption.ico" type="image/vnd.microsoft.icon" />
<link rel="canonical" href="https://softoption.us:8888/node/714" />
<link rel="shortlink" href="https://softoption.us:8888/node/714" />
<link rel="prev" href="/node/712" />
<link rel="up" href="/node/712" />
<link rel="next" href="/node/721" />

    <title>Let Polymorphism in Mini ML | SoftOption ®</title>
    <link rel="stylesheet" media="all" href="/sites/default/files/css/css_khtctZLP2jpcMApxNI6U-xr0v74EZxxWBYqs0fkxKLw.css?delta=0&amp;language=en&amp;theme=bartik&amp;include=eJxdjVEKwCAMxS6k80zVFSnWFnwycKcf-xnM3wSSTGNKS0UJWEcmcMh_5N6i0SWVprhttjNAlbFh8_PrVPVMGjGXitVQfHAyH51Ubg5YmNzTO34AqBU1ug" />
<link rel="stylesheet" media="all" href="/sites/default/files/css/css_QgIKm-2l_vW99o8hYWJe1FpLS9-NLija21X9jfKiHr0.css?delta=1&amp;language=en&amp;theme=bartik&amp;include=eJxdjVEKwCAMxS6k80zVFSnWFnwycKcf-xnM3wSSTGNKS0UJWEcmcMh_5N6i0SWVprhttjNAlbFh8_PrVPVMGjGXitVQfHAyH51Ubg5YmNzTO34AqBU1ug" />
<link rel="stylesheet" media="print" href="/sites/default/files/css/css_W5Rfue91kk7MvZw9gOwKjBTXLOG9VGkqiJXGc6DDCAQ.css?delta=2&amp;language=en&amp;theme=bartik&amp;include=eJxdjVEKwCAMxS6k80zVFSnWFnwycKcf-xnM3wSSTGNKS0UJWEcmcMh_5N6i0SWVprhttjNAlbFh8_PrVPVMGjGXitVQfHAyH51Ubg5YmNzTO34AqBU1ug" />

    
  </head>
  <body class="layout-one-sidebar layout-sidebar-second path-node page-node-type-book">
        <a href="#main-content" class="visually-hidden focusable skip-link">
      Skip to main content
    </a>
    
      <div class="dialog-off-canvas-main-canvas" data-off-canvas-main-canvas>
    <div id="page-wrapper">
  <div id="page">
    <header id="header" class="header" role="banner">
      <div class="section layout-container clearfix">
        
          <div class="clearfix region region-header">
    <div id="block-navigationiconsintheheader" class="block block-block-content block-block-content84cc7405-2724-49c9-8057-fe7d1e094f86">
  
      <h2>Navigation Icons in the header</h2>
    
      <div class="content">
      
            <div class="clearfix text-formatted field field--name-body field--type-text-with-summary field--label-hidden field__item"><!-- mf --><div id="icons"><a href="/" title="Home page"><img alt="Home" height="26" src="/themes/custom/bartikSoftOptionImages/homeMF.svg" width="32" loading="lazy"></a> <a href="/contact" title="Contact us"><img alt="Contact" height="18" src="/themes/custom/bartikSoftOptionImages/envelopeMF.svg" width="24" loading="lazy"></a> <a href="/sitemap" title="Sitemap"><img alt="Sitemap" height="26" src="/themes/custom/bartikSoftOptionImages/sitemapMF.svg" width="30" loading="lazy"></a> <a href="/search/content" title="Search"><img alt="Search" height="26" src="/themes/custom/bartikSoftOptionImages/searchMF.svg" width="26" loading="lazy"></a></div>
<!-- mf --></div>
      
    </div>
  </div>
<div id="block-bartik-branding" class="clearfix site-branding block block-system block-system-branding-block">
  
    
          <div class="site-branding__text">
              <div class="site-branding__name">
          <a href="/" rel="home">SoftOption ®</a>
        </div>
                </div>
  </div>

  </div>

        
      </div>
    </header>
          <div class="highlighted">
        <aside class="layout-container section clearfix" role="complementary">
            <div class="region region-highlighted">
    <div data-drupal-messages-fallback class="hidden"></div>

  </div>

        </aside>
      </div>
            <div id="main-wrapper" class="layout-main-wrapper layout-container clearfix">
      <div id="main" class="layout-main clearfix">
          <div class="region region-breadcrumb">
    <div id="block-bartik-breadcrumbs" class="block block-system block-system-breadcrumb-block">
  
    
      <div class="content">
        <nav class="breadcrumb" role="navigation" aria-labelledby="system-breadcrumb">
    <h2 id="system-breadcrumb" class="visually-hidden">Breadcrumb</h2>
    <ol>
          <li>
                  <a href="/">Home</a>
              </li>
          <li>
                  <a href="/node/718">Lambda Calculus with Elementary Type Theory</a>
              </li>
          <li>
                  <a href="/node/712">Let Polymorphism and a Mini-ML Type System</a>
              </li>
        </ol>
  </nav>

    </div>
  </div>

  </div>

        <main id="content" class="column main-content" role="main">
          <section class="section">
            <a id="main-content" tabindex="-1"></a>
              <div class="region region-content">
    <div id="block-bartik-page-title" class="block block-core block-page-title-block">
  
    
      <div class="content">
      

  <h1 class="title page-title"><span class="field field--name-title field--type-string field--label-hidden">Let Polymorphism in Mini ML</span>
</h1>


    </div>
  </div>
<div id="block-bartiksoftoption-system-main" class="block block-system block-system-main-block">
  
    
      <div class="content">
      
<article data-history-node-id="714" class="node node--type-book node--view-mode-full clearfix">
  <header>
    
          
      </header>
  <div class="node__content clearfix">
    
            <div class="clearfix text-formatted field field--name-body field--type-text-with-summary field--label-hidden field__item"><h6 style="text-align:right">9/2/21</h6>
<h2>Let polymorphism</h2>
<p>We would like to have polymorphism in certain circumstances. For example, we would like to have the same identity function&nbsp;λx:x that could be used on Booleans and Integers, without having to have two separate identity functions, one of type B-&gt;B and the other of type I-&gt;I .</p>
<p>The usual way to do this, in this setting, is via a 'let' construction. Most functional&nbsp;programming languages have an expression form similar to</p>
<p style="margin-left: 40px;"><strong>let</strong> &lt;variable&gt; = &lt;expression1&gt; <strong>in</strong> &lt;expression2&gt;</p>
<p>For example, the following is a well-formed expression in the computer language Haskell</p>
<p style="margin-left: 40px;">let identity =&nbsp;\x-&gt;x in (identity 7, identity False)&nbsp; &nbsp; &nbsp;(and a Haskell&nbsp;interpreter will return&nbsp;(7,False) as the value for this.)</p>
<p>What we are seeing here is a local definition of 'identity'. The expression&nbsp;\x-&gt;x is Haskell's version of&nbsp;λx.x. Haskell has a notation for ordered pair and it is ( , ). The expression being evaluated consists of an ordered pair whose first component is identity applied to 7 with a second component of identity applied to False. For Haskell this is well-typed and has a value&nbsp;(7,False). This means that the identity function that has been defined is polymorphic— it has been applied both to Integers and Booleans without any problem or issue.</p>
<p>Haskell, of course, has a much more sophisticated type system than mini-ML But a local definition let construction is a way of bringing polymorphism into mini-ML</p>
<p>In a general hand-waving way, local definitions are not hard to do in lambda calculus. Say we wanted to define variableX as being expressionY (i.e. variableX=expressionY) and substitute&nbsp; ys for xs throughout expressionZ, all we need to do is to wrap a lambda x around z and apply that to y i.e.</p>
<p style="margin-left: 40px;">(λvariableX.expressionZ&nbsp;expressionY)&nbsp;&nbsp; ... on reduction that will substitute ys for xs in z</p>
<p>however, there can be details and complications. For example, can the variable x appear within the expression y (as might be the case with recursion)? what about capturing and problems with substitution (where, perhaps, several lets are nested one within another)? Also, will this be able to provide the polymorphism we are looking for?</p>
<p>For this extension to lambda calculus, the construction</p>
<p style="margin-left: 40px;"><strong>let</strong> &lt;variable&gt; = &lt;expression1&gt; <strong>in</strong> &lt;expression2&gt;</p>
<p>will be accepted as creating well-formed formulas in the extended lambda calculus. [This does introduce questions of how that construction is to be reduced to normal form. However, at present the interest is with types, we will set that aside.] Also, for simplicity, we'll not let the&nbsp;&lt;variable&gt; appear within&nbsp;&lt;expression1&gt;.</p>
<p>As mentioned, the let addition is similar to a plain lambda calculus expression with form</p>
<p style="margin-left: 40px;">(λvarX. e<sub>2</sub>&nbsp; e<sub><span style="font-size: 11.6667px;">1</span></sub>)</p>
<p><iframe height="600" id="#editorJHM" scrolling="yes" src="/sites/all/js/lambdaWidgets/src/parseMiniMLWithLet.jsexe/index.html" width="100%">If you can see this, your browser does not understand IFRAME.</iframe></p>
<p>How might that entire expression form be typed? What might be a typing rule for it? One obvious approach is to work out the type of e<sub>1&nbsp;</sub>then calculate the type of&nbsp;e<sub><span style="font-size: 11.6667px;">2</span></sub> using the type of e<sub><span style="font-size: 11.6667px;">2&nbsp;</span></sub>as the types for all the occurrences of varX in e<sub><span style="font-size: 11.6667px;">2</span></sub>. That would give a typing rule like Possible Typing Rule 0</p>
<table border="1" cellpadding="1" cellspacing="1" style="width: 300px;margin-left: 40px">
<tbody>
<tr>
<td>Γ ⊢ e<sub>1</sub>:τ&nbsp; and&nbsp;Γ∪{x:τ)<sub>&nbsp;</sub>} ⊢ e<sub>2</sub>:&nbsp;σ<br>
			<strike>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strike><br>
			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Γ ⊢ (let x=e<sub>1</sub>&nbsp;in e<sub>2</sub>) : σ</td>
</tr>
</tbody>
</table>
<p>Unfortunately this will not produce the effect we are looking for. The reason is that every occurrence of x in&nbsp;e<sub>2&nbsp;</sub>will have the same type, and there are expressions where different occurrences of x should have different types</p>
<p>The Haskell example above uses an ordered pair, which is not available in our lambda calculus. But there are suitable expressions to illustrate the problem.</p>
<p style="margin-left: 40px;">let identity&nbsp;=&nbsp;λx. x in<br>
&nbsp; &nbsp;let ignore = (identity True) in<br>
&nbsp; &nbsp; &nbsp; (identity 2)</p>
<p>We would expect this expression to have a value of (or to reduce to) 2 which is an Integer i.e. of type I. Using Possible Typing Rule 0</p>
<p>&nbsp;Γ , the final environment is empty, x is identity, e<sub>1 </sub>is&nbsp;λx. x , and&nbsp;e<sub>2 </sub>is let ignore = (identity True) in (identity 2)</p>
<table border="1" cellpadding="1" cellspacing="1" style="width: 600px;margin-left: 40px">
<tbody>
<tr>
<td>⊢ (λx. x):τ&nbsp; and {identity:τ<sub>&nbsp;</sub>} ⊢(let ignore = (identity True) in (identity 2):&nbsp;σ<br>
			<strike>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strike><br>
			&nbsp; &nbsp; &nbsp; &nbsp; ⊢ (let identity&nbsp;=&nbsp;λx. x in (let ignore = identity True in identity 2)) : σ</td>
</tr>
</tbody>
</table>
<p>Then, on the right hand branch, for&nbsp;{identity:τ<sub>&nbsp;</sub>} ⊢(let ignore = identity True in identity 2):&nbsp;σ ,&nbsp;&nbsp;Γ is&nbsp;{identity:τ<sub>&nbsp;</sub>, x is ignore,&nbsp;e<sub>1<sup>'&nbsp;</sup> </sub>is&nbsp;(identity True) and&nbsp;e<sub>2<sup>'&nbsp; </sup></sub>is (identity 2)</p>
<table border="1" cellpadding="1" cellspacing="1" style="width: 600px;margin-left: 40px">
<tbody>
<tr>
<td>{identity:τ<sub>&nbsp;</sub>} ⊢ (identity True):τ&nbsp; and {identity:τ<sub>&nbsp;</sub>}∪{ignore:τ) ⊢(identity 2):&nbsp;σ<br>
			<strike>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strike><br>
			&nbsp; &nbsp; &nbsp; &nbsp;{identity:τ<sub>&nbsp;</sub>} ⊢(let ignore = identity True in identity 2):&nbsp;σ</td>
</tr>
</tbody>
</table>
<p>But we are in trouble.&nbsp;(identity True) and&nbsp;(identity 2) are applications, and the Application rule is not able to type identity in this case.</p>
<p>Let polymorphism has a definite suggestion here.</p>
<h2>An 'easy' explanation of Let polymorphism.</h2>
<p>1. All lambda expressions are going to be monomorphic. That means that were we to annotate the lambda variable to get a view of it, all lambda expressions would look similar to this.</p>
<p style="margin-left: 40px;">λx:&lt;type&gt;. &lt;scope&gt;</p>
<p>The important point here is that &lt;type&gt; is a plain type and not a universally quantified type-scheme. So the &lt;type&gt; is monomorphic. It may have type variables in it, but if those are valued (perhaps by unification) they will be valued only once (and uniquely).</p>
<p>2. The variable in a let expression is polymorphic.&nbsp;That means that were we to annotate the let variable to get a view of it, all let expressions would look similar to this.</p>
<p style="margin-left: 40px;">let x:&lt;type-scheme&gt;= e<sub>1</sub> in&nbsp;e<sub><span style="font-size: 11.6667px;">2</span></sub></p>
<p>The type scheme here likely will be a full blown type scheme with a universal quantifier and a list of quantified type variables. Which type variables you may ask? Well, there is a little excursion needed here into <em>free type variables (ftvs) . </em>The type for e<sub>1&nbsp;</sub>, were it to be evaluated on its own, might have free type variables in it, denote these by ftv(e<sub>1</sub>) . And, in the general case for finding types, there will be an environment&nbsp;&nbsp;Γ . Now,&nbsp;&nbsp;Γ is a collection of pairs of term variables and type schemes. Those type schemes may have free variables in them, and all of those in Γ can be collected up. These may be denoted by ftv(Γ). Our interest is in the free variable of&nbsp;e<sub>1</sub> which are not free variables in Γ i.e. ftv(e<sub>1</sub>)-ftv(Γ). Those are the ones that should be used as the quantified variables in the corresponding type scheme. So, for example, if the type of&nbsp;&nbsp;e<sub>1&nbsp;</sub>is typeVar1-&gt;typeVar2 and neither of these are free in the environment then&nbsp;∀typeVar1, typeVar2 (typeVar1-&gt;typeVar2). Were we to annotate&nbsp;the opening segment of the let, it would look like this, schematically&nbsp;</p>
<p style="margin-left: 40px;">let x:∀typeVar1, typeVar2 (typeVar1-&gt;typeVar2)= e<sub>1</sub> in&nbsp;e<sub><span style="font-size: 11.6667px;">2</span></sub></p>
<p>3. The next step is to use instantiations of the type scheme, instantiations that have all new type variables. The scheme&nbsp;∀typeVar1, typeVar2 (typeVar1-&gt;typeVar2), for example, has instantiations (typeVar100-&gt;typeVar101),&nbsp;(typeVar102-&gt;typeVar103), and many more.</p>
<p>For each occurrence of x in&nbsp;e<sub><span style="font-size: 11.6667px;">2</span></sub> , when considering its type, a new type instantiation will be used. This means, to hark back to an earlier example, when considering the types of the sub-expressions (identity True) and (identity 2) , they will have entirely different type variables one from the other (and this will allow them to be solved simultaneously).</p>
<p>4. This can all be rolled into a single rule</p>
<table border="1" cellpadding="1" cellspacing="1" style="width: 640px;margin-left: 40px">
<tbody>
<tr>
<td>Γ ⊢ e<sub>1</sub>:τ&nbsp; and&nbsp;Γ∪{x:∀A(τ))<sub>&nbsp;</sub>} ⊢ e<sub>2</sub>:&nbsp;σ&nbsp; &nbsp; &nbsp;i) the term variable x needs not to have a prior valuation in&nbsp;&nbsp;Γ&nbsp;and<br>
			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii) A is the list of free variables&nbsp; ftv(e<sub>1</sub>)-ftv(Γ)<br>
			<strike>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strike><br>
			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Γ ⊢ (let x=e<sub>1</sub>&nbsp;in e<sub>2</sub>) : σ</td>
</tr>
</tbody>
</table>
</div>
      
  <nav id="book-navigation-718" class="book-navigation" role="navigation" aria-labelledby="book-label-718">
    
          <h2 class="visually-hidden" id="book-label-718">Book traversal links for Let Polymorphism in Mini ML</h2>
      <ul class="book-pager">
              <li class="book-pager__item book-pager__item--previous">
          <a href="/node/712" rel="prev" title="Go to previous page"><b>‹</b> Let Polymorphism and a Mini-ML Type System</a>
        </li>
                    <li class="book-pager__item book-pager__item--center">
          <a href="/node/712" title="Go to parent page">Up</a>
        </li>
                    <li class="book-pager__item book-pager__item--next">
          <a href="/node/721" rel="next" title="Go to next page">MiniML: Constraints <b>›</b></a>
        </li>
          </ul>
      </nav>

  </div>
</article>

    </div>
  </div>

  </div>

          </section>
        </main>
                          <div id="sidebar-second" class="column sidebar">
            <aside class="section" role="complementary">
                <div class="region region-sidebar-second">
    <div id="block-siteimage" class="block block-block-content block-block-content0ded7434-e98a-4e3c-92cc-5dc0bb6bd1b4">
  
    
      <div class="content">
      
            <div class="clearfix text-formatted field field--name-body field--type-text-with-summary field--label-hidden field__item"><script type="text/javascript">
<!--
 var imlocation = "/files/RandomImages/";
 var currentdate = 0;
 var image_number = 0;
 function ImageArray (n) {
   this.length = n;
   for (var i =1; i <= n; i++) {
     this[i] = ' '
   }
 }
 image = new ImageArray(16)
 image[0] = '1.png'
 image[1] = '2.png'
 image[2] = '3.png'
 image[3] = '4.png'
 image[4] = '5.png'
 image[5] = '6.png'
 image[6] = '7.png'
 image[7] = '8.png'
 image[8] = '9.png'
 image[9] = '10.png'
 image[10] = '11.png'
 image[11] = '12.png'
 image[12] = '13.png'
 image[13] = '14.png'
 image[14] = '15.png'
 image[15] = '16.png'
 var rand = 60/image.length
 function randomimage() {
 	currentdate = new Date()
 	image_number = currentdate.getSeconds()
 	image_number = Math.floor(image_number/rand)
 	return(image[image_number])
 }
 

document.write("<img src='" + imlocation + randomimage()+ "'>");






//-->
</script></div>
      
    </div>
  </div>

<nav role="navigation" aria-labelledby="block-bartik-tools-menu" id="block-bartik-tools" class="block block-menu navigation menu--tools">
      
  <h2 id="block-bartik-tools-menu">Navigation</h2>
  

        <div class="content">
            <div class="menu-toggle-target menu-toggle-target-show" id="show-block-bartik-tools"></div>
      <div class="menu-toggle-target" id="hide-block-bartik-tools"></div>
      <a class="menu-toggle" href="#show-block-bartik-tools">Show &mdash; Navigation</a>
      <a class="menu-toggle menu-toggle--hide" href="#hide-block-bartik-tools">Hide &mdash; Navigation</a>
      
              <ul class="clearfix menu">
                    <li class="menu-item">
        <a href="/browse" title="Items to browse." data-drupal-link-system-path="node/208">Browse</a>
              </li>
                <li class="menu-item">
        <a href="/search/content" data-drupal-link-system-path="search/content">Search</a>
              </li>
                <li class="menu-item">
        <a href="/sitemap" title="Display a site map with RSS feeds." data-drupal-link-system-path="sitemap">Site map</a>
              </li>
        </ul>
  


    </div>
  </nav>
<div id="block-booknavigation" class="block block-book block-book-navigation">
  
    
      <div class="content">
      
              <ul class="menu">
                    <li class="menu-item">
        <a href="/node/671" hreflang="en">Simply Typed Lambda Calculus</a>
              </li>
                <li class="menu-item menu-item--collapsed">
        <a href="/node/676" hreflang="en">Junior Hindley-Milner I</a>
              </li>
                <li class="menu-item">
        <a href="/node/680" hreflang="en">Polymorphism, Annotation, and Decidable Type Inference</a>
              </li>
                <li class="menu-item menu-item--expanded menu-item--active-trail">
        <a href="/node/712" hreflang="en">Let Polymorphism and a Mini-ML Type System</a>
                                <ul class="menu">
                    <li class="menu-item menu-item--active-trail">
        <a href="/node/714" hreflang="en">Let Polymorphism in Mini ML</a>
              </li>
                <li class="menu-item">
        <a href="/node/721" hreflang="en">MiniML: Constraints</a>
              </li>
                <li class="menu-item">
        <a href="/node/717" hreflang="en">MiniML: Solving the Constraints</a>
              </li>
                <li class="menu-item">
        <a href="/node/719" hreflang="en">MiniML NOR Reduction with Expression Type</a>
              </li>
                <li class="menu-item">
        <a href="/node/722" hreflang="en">MiniML: Drawing It to a Conclusion</a>
              </li>
        </ul>
  
              </li>
                <li class="menu-item">
        <a href="/node/723" hreflang="en">Polymorphic Lambda Calculus: System F</a>
              </li>
                <li class="menu-item menu-item--collapsed">
        <a href="/node/672" hreflang="en">Intuitionistic Propositional Logic</a>
              </li>
        </ul>
  


    </div>
  </div>

  </div>

            </aside>
          </div>
              </div>
    </div>
        <footer class="site-footer">
      <div class="layout-container">
                          <div class="site-footer__bottom">
              <div class="region region-footer-fifth">
    <div id="block-bartiksoftoption-block-6" class="block block-block-content block-block-content52898772-4b33-4c3e-98d1-b8ffdd41102e">
  
    
      <div class="content">
      
            <div class="clearfix text-formatted field field--name-body field--type-text-with-summary field--label-hidden field__item">Copyright SoftOption ® Ltd. (New Zealand). Email: <a href="mailto:support@SoftOption.Us">support@SoftOption.Us</a></div>
      
    </div>
  </div>

  </div>

          </div>
              </div>
    </footer>
  </div>
</div>

  </div>

    
    <script type="application/json" data-drupal-selector="drupal-settings-json">{"path":{"baseUrl":"\/","pathPrefix":"","currentPath":"node\/714","currentPathIsAdmin":false,"isFront":false,"currentLanguage":"en"},"pluralDelimiter":"\u0003","suppressDeprecationErrors":true,"google_analytics":{"account":"G-CW0S29TLQS","trackOutbound":true,"trackMailto":true,"trackTel":true,"trackDownload":true,"trackDownloadExtensions":"7z|aac|arc|arj|asf|asx|avi|bin|csv|doc(x|m)?|dot(x|m)?|exe|flv|gif|gz|gzip|hqx|jar|jpe?g|js|mp(2|3|4|e?g)|mov(ie)?|msi|msp|pdf|phps|png|ppt(x|m)?|pot(x|m)?|pps(x|m)?|ppam|sld(x|m)?|thmx|qtm?|ra(m|r)?|sea|sit|tar|tgz|torrent|txt|wav|wma|wmv|wpd|xls(x|m|b)?|xlt(x|m)|xlam|xml|z|zip"},"statistics":{"data":{"nid":"714"},"url":"\/modules\/contrib\/statistics\/statistics.php"},"user":{"uid":0,"permissionsHash":"cd3d927c0e91f5444b560052ed2f3907b0b1a7d67939ee3e1d9d0bb7ebab88dd"}}</script>
<script src="/sites/default/files/js/js_8QBjledv09z8pzIS-vyTO6xcgINbsE-jAQBxU-jZLnc.js?scope=footer&amp;delta=0&amp;language=en&amp;theme=bartik&amp;include=eJxLz89Pz0mNT8xLzKksyUwu1k9HE9ApLkksySwGy6UUlRYk5ughRAAWtRkf"></script>

  </body>
</html>
